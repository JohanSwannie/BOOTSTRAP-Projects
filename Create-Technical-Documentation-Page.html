<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Create a Technical Documentation Page</title>
</head>

<body>
  <nav id="navbar">
    <header id="heading">
      <h1>Python</h1>
      <h1>Documentation</h1>
    </header>
    <a class="nav-link" href="#introduction">Introduction</a>
    <a class="nav-link" href="#data-model">Data Model</a>
    <a class="nav-link" href="#execution-model">Execution Model</a>
    <a class="nav-link" href="#import-system">Import System</a>
    <a class="nav-link" href="#expressions">Expressions</a>
    <a class="nav-link" href="#simple-statements">Simple Statements</a>
  </nav>

  <main id="main-doc">
    <section class="main-section" id="introduction">
      <h2>Introduction</h2>
      <p>This reference manual describes the Python programming language. It is not intended as a tutorial.While I am trying to be as precise as possible, I chose to use English rather than formal specifications for everything except syntax and
        lexical analysis. This should make the document more understandable to the average reader, but will leave room for ambiguities.</p>
      <p>A Python program is read by a parser. Input to the parser is a stream of tokens, generated by the lexical analyzer. This chapter describes how the lexical analyzer breaks a file into tokens.</p>
      <p>A Python program is divided into a number of logical lines.</p>
      <ul>
        <li>Logical lines - The end of a logical line is represented by the token NEWLINE. Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound statements). A logical line
          is constructed from one or more physical lines by following the explicit or implicit line joining rules.</li><br>
        <li>Physical lines - A physical line is a sequence of characters terminated by an end-of-line sequence. In source files and strings, any of the standard platform line termination sequences can be used - the Unix form using ASCII LF
          (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform. The end of input
          also serves as an implicit terminator for the final physical line.</li>
      </ul>
    </section>
    <section class="main-section" id="data-model">
      <h2>Data Model</h2>
      <h4>Objects, values and types</h4>
      <ul>
        <li>Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also
          represented by objects</li><br>
        <li>Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is’ operator compares the identity of two objects; the id()
          function returns an integer representing its identity.</li>
      </ul>
      <p>Python distinguishes between integers, floating point numbers, and complex numbers</p>
      <p>There are two types of integers</p>
      <ul>
        <li>Integers (int) - These represent numbers in an unlimited range, subject to available (virtual) memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a
          variant of 2’s complement which gives the illusion of an infinite string of sign bits extending to the left.</li><br>
        <li>Booleans (bool)
          These represent the truth values False and True. The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1,
          respectively, in almost all contexts, the exception being that when converted to a string, the strings "False" or "True" are returned, respectively.</li>
      </ul>
    </section>
    <section class="main-section" id="execution-model">
      <h2>Execution model</h2>
      <h4>Structure of a program</h4>
      <p>A Python program is constructed from code blocks. A block is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block.
        A script file (a file given as standard input to the interpreter or specified as a command line argument to the interpreter) is a code block. A script command (a command specified on the interpreter command line with the -c option) is a code
        block. A module run as a top level script (as module __main__) from the command line using a -m argument is also a code block. The string argument passed to the built-in functions eval() and exec() is a code block.</p>

      <p>A code block is executed in an execution frame. A frame contains some administrative information (used for debugging) and determines where and how execution continues after the code block’s execution has completed.</p>
      <h4>Binding of names</h4>
      <p>Names refer to objects. Names are introduced by name binding operations.</p>
      <p>The following constructs bind names:</p>
      <ul>
        <li>formal parameters to functions</li>
        <li>class definitions</li>
        <li>function definitions</li>
        <li>assignment expressions</li>
        <li>targets that are identifiers if occurring in an assignment</li>
        <ul>
          <li>for loop header</li>
          <li>after as in a with statement, except clause or in the as-pattern in structural pattern matching</li>
          <li>in a capture pattern in structural pattern matching</li>
        </ul>
        <li>import statements</li>
      </ul>
      <h4>Resolution of names</h4>
      <p>A scope defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block. If the definition occurs in a function block, the scope extends to any blocks contained within the defining
        one, unless a contained block introduces a different binding for the name.</p>
    </section>
    <section class="main-section" id="import-system">
      <h2>The Import System</h2>
      <p>Python code in one module gains access to the code in another module by the process of importing it. The import statement is the most common way of invoking the import machinery, but it is not the only way. Functions such as
        importlib.import_module() and built-in __import__() can also be used to invoke the import machinery.</p>
      <p>The import statement combines two operations; it searches for the named module, then it binds the results of that search to a name in the local scope. The search operation of the import statement is defined as a call to the __import__()
        function, with the appropriate arguments. The return value of __import__() is used to perform the name binding operation of the import statement. See the import statement for the exact details of that name binding operation.</p>
      <p>A direct call to __import__() performs only the module search and, if found, the module creation operation. While certain side-effects may occur, such as the importing of parent packages, and the updating of various caches (including
        sys.modules), only the import statement performs a name binding operation.</p>
      <p>When an import statement is executed, the standard builtin __import__() function is called. Other mechanisms for invoking the import system (such as importlib.import_module()) may choose to bypass __import__() and use their own solutions to
        implement import semantics.</p>
      <p>When a module is first imported, Python searches for the module and if found, it creates a module object 1, initializing it. If the named module cannot be found, a ModuleNotFoundError is raised. Python implements various strategies to search
        for the named module when the import machinery is invoked. These strategies can be modified and extended by using various hooks described in the sections below.</p>
    </section>
    <section class="main-section" id="expressions">
      <h2>Expressions</h2>
      <p>This chapter explains the meaning of the elements of expressions in Python.</p>
      <h4>Arithmetic conversions</h4>
      <p>When a description of an arithmetic operator below uses the phrase “the numeric arguments are converted to a common type”, this means that the operator implementation for built-in types works as follows:</p>
      <ul>
        <li>If either argument is a complex number, the other is converted to complex.</li>
        <li>Otherwise, if either argument is a floating point number, the other is converted to floating point.</li>
        <li>Otherwise, both must be integers and no conversion is necessary.</li>
      </ul>
      <h4>Atoms</h4>
      <p>Atoms are the most basic elements of expressions. The simplest atoms are identifiers or literals. Forms enclosed in parentheses, brackets or braces are also categorized syntactically as atoms.</p>
      <p>The syntax for atoms is: <code>atom ::= identifier | literal | enclosure enclosure ::= parenth_form | list_display | dict_display | set_display | generator_expression | yield_atom</code></p>
      <h4>Identifiers</h4>
      <p>An identifier occurring as an atom is a name. See section Identifiers and keywords for lexical definition and section Naming and binding for documentation of naming and binding.</p>
      <p>When the name is bound to an object, evaluation of the atom yields that object. When a name is not bound, an attempt to evaluate it raises a NameError exception.</p>
      <h4>Literals</h4>
      <p>Python supports string and bytes literals and various numeric literals: <code>literal ::= stringliteral | bytesliteral | integer | floatnumber | imagnumber</code></p>
      <h4>Parenthesized forms</h4>
      <p>A parenthesized form is an optional expression list enclosed in parentheses: <code>parenth_form ::= "(" [starred_expression] ")"</code></p>
      <h4>Displays for lists, sets and dictionaries</h4>
      <p>For constructing a list, a set or a dictionary Python provides special syntax called “displays”, each of them in two flavors:</p>
      <ul>
        <li>Either the container contents are listed explicitly, or</li>
        <li>They are computed via a set of looping and filtering instructions, called a comprehension.</li>
      </ul>
    </section>
    <section class="main-section" id="simple-statements">
      <h2>Simple statements</h2>
      <h4>Expression statements</h4>
      <p>Expression statements are used (mostly interactively) to compute and write a value, or (usually) to call a procedure (a function that returns no meaningful result; in Python, procedures return the value None). Other uses of expression
        statements are allowed and occasionally useful. The syntax for an expression statement is: <code>expression_stmt ::= starred_expression</code></p>
      <p>An expression statement evaluates the expression list (which may be a single expression).</p>
      <h4>Assignment statements</h4>
      <p>Assignment statements are used to (re)bind names to values and to modify attributes or items of mutable objects.</p>
      <h4>Augmented assignment statements</h4>
      <p>Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement.</p>
      <h4>Annotated assignment statements</h4>
      <p>Annotation assignment is the combination, in a single statement, of a variable or attribute annotation and an optional assignment statement <code>annotated_assignment_stmt ::= augtarget ":" expression ["=" (starred_expression |
          yield_expression)]</code></p>
    </section>
    <footer>
      <h3>Reference</h3>
      <ul>
        <li>All the documentation in this page is taken from <a href="https://www.python.org/doc/">Python.org</a></li>
      </ul>
    </footer>
  </main>

</body>

</html>
